from cns.buffer import SoftwareRingBuffer
from cns.util.signal import rfft
from cns.data.persistence import append_node
from enthought.traits.api import HasTraits, CFloat, Property, Array, Int, Event, \
    Instance, on_trait_change, Bool, Any, String, Float, cached_property, List, Str, \
    DelegatesTo, Tuple
import numpy as np
import tables
    

class AbstractChannel(HasTraits):

    fs = CFloat
    window = CFloat(10)
    updated = Event
    samples = Property(Int, depends_on='window, fs')

    t = Property(Array)
    #t_windowed = Property(Array)
    t_windowed_bounds = Property(Tuple, depends_on='window')
    signal_windowed_bounds = Property(Tuple)

    # Used to fill in empty values.
    window_fill = Float(np.nan)
    
    @cached_property
    def _get_t_windowed_bounds(self):
        return -self.window, 0
    
    def _get_signal_windowed_bounds(self):
        return self.signal_windowed.min(), self.signal_windowed.max()
    
    def _get_window_box(self):
        return zip(self.t_windowed_bounds, self.signal_windowed_bounds)

    @cached_property
    def _get_samples(self):
        return int(self.window * self.fs)
    
    def _get_t(self):
        return np.arange(-len(self), 0) / self.fs

    def t_windowed(self):
        return self._get_t_windowed()

    @profile
    def _get_t_windowed(self):
        return np.arange(-self.samples, 0) / self.fs

    def get_range(self, lb, ub):
        lb = int(lb * self.fs)
        ub = int(ub * self.fs)
        return self.signal[lb:ub]
    
    def fft(self):
        return rfft(self.fs, self.signal_windowed)

    source = Any

    def acquire(self):
        self.send(self.source.next())
    
    next = acquire
    
class Channel(AbstractChannel):
    
    signal = Property(Array)
    #signal_windowed = Property(Array)

    def __len__(self):
        return len(self.signal)
    
    def signal_windowed(self):
        return self.signal[-self.samples:]
        #return self._get_signal_windowed()
    
    @profile
    def _get_signal_windowed_buf_partial(self):
        length = len(self)
        delta = self.samples - length
        if delta <= 0:
            self._get_signal_windowed = self._get_signal_windowed_buf_full
            return self._get_signal_windowed()
        elif length:
            result = np.ones(self.samples) * self.window_fill
            result[-length:] = self.signal[:]
            return result
        else:
            return np.ones(self.samples) * self.window_fill

    @profile
    def _get_signal_windowed_buf_full(self):
        length = len(self)
        return self.signal[int(length - self.samples):length]
    
    _get_signal_windowed = _get_signal_windowed_buf_partial

class FileChannel(Channel):
    
    dtype = Any
    node = Any
    name = String('FileChannel')
    buffer = Any
    
    def _buffer_default(self):
        atom = tables.Atom.from_dtype(np.dtype(self.dtype))
        buffer = append_node(self.node, self.name, 'EArray', atom, (0,))
        buffer.setAttr('fs', self.fs)
        return buffer
        
    def _get_signal(self):
        return self.buffer

    def _get_signal_windowed_buf_partial(self):
        length = len(self)
        delta = self.samples - length
        if delta <= 0:
            self._get_signal_windowed = self._get_signal_windowed_buf_full
            return self._get_signal_windowed()
        elif length:
            result = np.ones((self.samples, self.buffer.shape[-1])) * self.window_fill
            result[-length:] = self.buffer[:]
            return result
        else:
            return np.ones((self.samples, self.buffer.shape[-1])) * self.window_fill

    def _get_signal_windowed_buf_full(self):
        length = len(self)
        return self.buffer[int(length - self.samples):length]

    _get_signal_windowed = _get_signal_windowed_buf_partial

    def send(self, data):
        self.buffer.append(data)
        self.updated = True

    def __len__(self):
        return len(self.buffer)
    
class BufferedChannel(Channel):

    buffer = Instance(SoftwareRingBuffer)
    signal = Property(Array(dtype='f'))

    def _buffer_default(self):
        return SoftwareRingBuffer(self.samples)
    
    def _get_signal(self):
        return self.buffer.data

    def _get_signal_windowed(self):
        return self.buffer.data

    def send(self, data):
        if len(data):
            self.buffer.write(data)
            self.updated = True
        
    def __len__(self):
        return self.buffer.length

class StaticChannel(Channel):

    _signal = Array(dtype='f')

    def _get_signal(self):
        return self._signal

    def _set_signal(self, signal):
        self._signal = signal

class MultiChannel(Channel):

    channels = Int(8)
    names = List(Str)
    
    def get_channel(self, channel):
        try:
            idx = self.names.index(channel)
        except ValueError:
            idx = channel
        return DerivedChannel(parent=self, idx=idx)
    
class DerivedChannel(Channel):
    
    parent = Instance(MultiChannel)
    updated = DelegatesTo('parent')
    
    # This is a hack due to a problem with one of the traits in the super class
    # 'depending' on fs.  This prevents us from treating it as a delegate.
    def _parent_changed(self, parent):
        parent.sync_trait('fs', self, mutual=False)
    
    def _get_signal(self):
        return self.parent.signal[:,self.idx]

class BufferedMultiChannel(BufferedChannel, MultiChannel):

    def _get_signal_windowed(self):
        return self.buffer.data
    
    def _buffer_default(self):
        return SoftwareRingBuffer((self.samples, self.channels))
        
class FileMultiChannel(FileChannel, MultiChannel):
    
    channels = Int(8)
    name = 'FileMultiChannel'
        
    def _buffer_default(self):
        atom = tables.Atom.from_dtype(np.dtype(self.dtype))
        buffer = append_node(self.node, self.name, 'EArray', atom, (0, self.channels))
        buffer.setAttr('fs', self.fs)
        buffer.setAttr('channels', self.channels)
        return buffer
        
class DecimatedChannel(AbstractChannel):

    buffer_min = Instance(SoftwareRingBuffer)
    buffer_max = Instance(SoftwareRingBuffer)
    signal_min = Property(Array)
    signal_max = Property(Array)

    def _buffer_min_default(self):
        return SoftwareRingBuffer(self.samples)

    def _buffer_max_default(self):
        return SoftwareRingBuffer(self.samples)

    def _get_signal_min(self):
        return self.buffer_min.data

    def _get_signal_max(self):
        return self.buffer_max.data

    def send(self, data):
        self.buffer_min.write(data[::2])
        self.buffer_max.write(data[1::2])
        self.updated = True
        
    def __len__(self):
        return self.buffer_min.length

class DecimatedMultiChannel(DecimatedChannel):

    channels = Int(8)

    def _buffer_min_default(self):
        return SoftwareRingBuffer((self.samples, self.channels))

    def _buffer_max_default(self):
        return SoftwareRingBuffer((self.samples, self.channels))

class SnippetChannel(AbstractChannel):

    buffer = Instance(SoftwareRingBuffer)
    samples = Int
    history = Int
    signal = Property(Array(dtype='f'))
    average_signal = Property(Array(dtype='f'))
    buffered = Int(0)
    buffer_full = Bool(False)

    @on_trait_change('samples, fs, history')
    def _configure_buffer(self):
        self.buffer = SoftwareRingBuffer((self.history, self.samples))

    def _get_t(self):
        return np.arange(-self.samples, 0) / self.fs

    def _get_signal(self):
        return self.buffer.buffered

    def send(self, data):
        # Ensure that 1D arrays containing a single snippet are broadcast 
        # properly to the correct shape.
        data.shape = (-1, self.samples)
        added = self.buffer.write(data)

        if self.buffer_full:
            self.updated = added, added
        else:
            self.buffered += added
            if self.buffered > self.history:
                self.buffer_full = True
                removed = self.buffered % self.history
                self.buffer_full
                self.updated = removed, added
            else:
                self.updated = 0, added

    def _get_average_signal(self):
        return self.buffer.buffered.mean(0)
    
    def __len__(self):
        return self.samples

function [spikes] = import_ums2000(filename, sort, varargin)
%   Neurobehavior by Buran BN and Sanes DH
%
%   IMPORT_UMS2000 Load spike waveforms from HDF5 file into Matlab
%
%   required parameters
%   -------------------
%   filename : string
%       name of file to load data from (must be generated by the
%       review_physiology.py script in the neurobehavior module).
%   sort : boolean
%       Run spike sorting algorithms before returning
%
%   Important!  See IMPORT_SPIKES for a list of the optional arguments that
%   you can pass along.
%
%   Returns struct containing spike waveform data that can be used directly by
%   UltraMegaSort2000.
% 
%   As a convenience feature, the filename of the source data (with the
%   extension stripped) is provided as spikes.base_filename so you can quickly
%   append your desired extension when saving the data.  It's probably good
%   practice to keep naming consistent.

    % Load the spike waveform data
    spikes = import_spikes(filename, varargin{:});
    
    fs = double(h5readatt(filename, '/', 'fs'));
    window_size = double(h5readatt(filename, '/', 'window_size'));
    cross_time = double(h5readatt(filename, '/', 'cross_time'));
    shadow = 0;
    
    params = ss_default_params(fs, 'window_size', window_size, ...
                               'cross_time', cross_time, ...
                               'shadow', shadow);
    spikes.params = params.params;
    
    spikes.spiketimes = spikes.timestamps./spikes.params.Fs;
    spikes.unwrapped_times = spikes.spiketimes;
    spikes.trials = ones(1, length(spikes.timestamps), 'single');

    % Now, let's reformat some of the fields so the same data structure is
    % compatible with UltraMegaSort2000.  Note that we upcast a lot of the
    % datatypes to double simply because Matlab does not seem to deal well with
    % non-double datatypes.
    align_sample = h5readatt(filename, '/', 'samples_before')+1.0;
    spikes.info.detect.align_sample = double(align_sample);
    spikes.info.detect.cov = double(h5read(filename, '/covariance_matrix'));
    spikes.info.detect.dur = [spikes.spiketimes(end)];
    stds = double(h5read(filename, '/noise_std'));
    thresh = double(h5read(filename, '/threshold'));
    
    extract_indices = spikes.info.detect.extract_indices;
    window_samples = spikes.info.detect.window_samples;
    
    spikes.info.detect.stds = stds(extract_indices);
    spikes.info.detect.thresh = thresh(extract_indices);
    
    % We need to pull out only the covariance data we need.wave
    cov_samples = length(extract_indices) * window_samples;
    % Explicitly requesting a 2D array is better than the implicit creation
    % of one ...
    cov_extracted = zeros(cov_samples, cov_samples);
    cov_full = double(h5read(filename, '/covariance_matrix'));
    
    % The code below is a beautiful example of why 0-based indexing is so
    % much better ... Anyway, we need to pull out the covariance data relating
    % to the channels we've extracted from the full covariance matrix.
    % http://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html
    for i = 1:length(extract_indices),
        for j = 1:length(extract_indices),
            % Indices required for obtaining slice of the full covariance matrix
            % to copy over ...
            x = extract_indices(i);
            y = extract_indices(j);
            full_xlb = (x-1)*window_samples+1;
            full_xub = x*window_samples;
            full_ylb = (y-1)*window_samples+1;
            full_yub = y*window_samples;

            e_xlb = (i-1)*window_samples+1;
            e_xub = i*window_samples;
            e_ylb = (j-1)*window_samples+1;
            e_yub = j*window_samples;

            xycov = cov_full(full_xlb:full_xub, full_ylb:full_yub);
            cov_extracted(e_xlb:e_xub, e_ylb:e_yub) = xycov;
    end
    spikes.info.detect.cov = cov_extracted;
    
    % UMS2000 needs to know what channel the detection event occured on.
    event_channels = zeros(length(spikes.waveforms), 1);
    detect_channels = spikes.info.detect.detect_channels;
    for i = 1:length(detect_channels),
        event_channels(spikes.channels==detect_channels(i)) = i;
    end
    spikes.info.detect.event_channel = event_channels;
    
    if sort,
        spikes = ss_align(spikes);
        spikes = ss_kmeans(spikes);
        spikes = ss_energy(spikes);
        spikes = ss_aggregate(spikes);
    end

    % Whoa, when I looked up how to use regular expressions in Matlab, someone
    % said text processing was one of Matlab's "hidden strengths".  Is that a
    % euphemisim for "bolted-on, poorly-implemented functionality"?  Personal
    % opinion aside, this appears to inherit from the Perl-style syntax.
    spikes.base_filename = regexprep(filename, '(.*)\.(h5|hd5|hdf5)', '$1');
end

function [spikes] = import_spikes(filename, varargin)
%   Neurobehavior by Buran BN and Sanes DH
%
%   IMPORT_SPIKES Load spike waveforms from HDF5 file into Matlab and cleans up
%   the data.  This is mainly a helper function for import_chronux and
%   import_ums2000 but can be used directly if desired.
%
%   Be sure to review the inline documentation in review_physiology.py for
%   the extract_features method before editing this code as there is
%   additional documentation regarding the structure of the HDF5 file
%   there.
%
%   Required arguments
%   ------------------
%   filename : string
%       name of file to load data from (must be generated by the
%       review_physiology.py script in the neurobehavior module).
%
%   Optional arguments
%   ------------------
%   waveform_channels : array (default - all channels)
%       For each event include only the waveforms from these channels
%   detect_channels : array (default - all channels)
%       Include only events that were detected on at least one of these channels
%   artifact_reject : {[], 'all', 'detect', 'waveform', array}
%       'all'
%           reject event if an artifact is detected on any channel,
%       'detect'
%           reject event if an artifact is observed on any of the channels
%           specified in 'detect_channels'
%       'waveform'
%           reject event if an artifact is observed on any of the channels
%           specified in 'waveform_channels'
%       array
%           reject event if an artifact is observed on any of the channels
%           specified in the vector
%       []
%           do not reject any event
%       Keep in mind that you have access to the waveforms so you can
%       perform your own reject algorithm
%   trial_mask : Empty or length 2 ()
%       TODO expound on this
%   max_features : integer (default inf)
%       Maximum number of features to return (useful for debugging since
%       the clustering algorithms can often be slow when working with a
%       large number of features).  Note that the entire dataset is loaded
%       into memory before truncating it.
%
%   Returns struct containing spike waveform data (waveforms, indices and
%   event times) that just needs a tiny bit of tweaking before it is 100%
%   compatible with UMS2000.

    % Let the inputParser handle massaging the input into the format we need and
    % setting default values as required.  This is a lot of work that Python
    % handles under the hood by default.

    p = inputParser();
    p.addRequired('filename', @ischar);
    p.addParamValue('waveform_channels', [], @isvector);
    p.addParamValue('detect_channels', [], @isvector);
    p.addParamValue('max_features', inf, @isscalar);
    p.addParamValue('artifact_reject', [], ...
                    @(x) isvector(x) || strcmpi(x, 'all') || ...
                         strcmpi(x, 'detect') || strcmpi(x, 'waveform') ...
                   );
    p.addParamValue('omit_prepost', true, @islogical);
    p.addParamValue('trial_range', [], ...
                    @(x) isvector(x) && (length(x) == 2 || isempty(x)) ...
                   );
    p.parse(filename, varargin{:});

    % Now, let's copy the results to the local namespace and get on with
    % the real work of this function.
    filename = p.Results.filename;
    waveform_channels = p.Results.waveform_channels;
    detect_channels = p.Results.detect_channels;
    max_features = p.Results.max_features;
    artifact_reject = p.Results.artifact_reject;
    trial_range = p.Results.trial_range;

    % Finally, we get to work on loading our data.
    
    % NOTE - All vectors are transposed so the shape is 1xN rather than Nx1
    % (which is how they appear to Matlab when loaded from the HDF5 file).
    % 1xN is required by some of UMS2000's functions for no good reason
    % other than the fact it was written in Matlab.
    
    extracted_channels = h5read(filename, '/extracted_channels');
    spikes.info.detect.extracted_channels = double(extracted_channels');
    
    % Indices of the threshold crossing in the raw waveform.  To compute
    % the time of the threshold crossing relative to the start of the
    % experiment, divide the indice by the sampling frequency.
    timestamps = double(h5read(filename, '/timestamps')');
    
    % The ordering of the array is C-continguous in the HDF5 file (e.g. the
    % NumPy default if you don't specify an order when creating the array).
    % Matlab requires all arrays to be Fortran-ordered, so this causes some
    % swapping of the axes when reading in the data.  Waveforms must be a
    % 3d array of [events, window_samples, channels].  By default, h5read
    % loads them as [window_samples, channels, events].  Next, we unstack
    % the waveforms so that it is essentially a 2D array of [events,
    % window_samples] where the waveform from each channel has been merged
    % into a single continuous waveform.
    waveforms = double(h5read(filename, '/waveforms'));
    waveforms = double(waveforms);
    waveforms = permute(waveforms, [3, 1, 2]);

    % Channel on which the event was detected
    channels = double(h5read(filename, '/channels')');
    channel_indices = double(h5read(filename, '/channel_indices')');
    
    % Now, if the user wants events requested only if they were detected on
    % certain channels, return those.
    if ~isempty(detect_channels),
        detect_mask = zeros(1, length(waveforms));
        for ch = detect_channels,
            detect_mask = detect_mask | (channels == ch);
        end
    else
        % We return everything
        detect_mask = ones(1, length(waveforms));
        detect_channels = extracted_channels;
    end
 
    % Now, extract only waveforms from the requested channels.
    if ~isempty(waveform_channels),
        extract_indices = get_indices(waveform_channels, extracted_channels);
        waveforms = waveforms(:, :, extract_indices);
        spikes.info.detect.extract_indices = extract_indices;
    else
        waveform_channels = extracted_channels;
        spikes.info.detect.extract_indices = 1:length(extracted_channels);
    end

    if ~isempty(artifact_reject),
        if strcmp(artifact_reject, 'detect'),
            artifact_reject = detect_channels;
        elseif strcmp(artifact_reject, 'waveform'),
            artifact_reject = waveform_channels;
        elseif strcmp(artifact_reject, 'all'),
            artifact_reject = extracted_channels;
        end
        
        % Artifacts are a 2D array [event, channel] indicating which channels
        % exceeded the aritfact threshold for any given event.  The transpose
        % operation is required because they are saved in C order in the HDF5
        % file.  Matlab views this as [channel, event] so we need to convert it
        % to the appropriate [event, channel] format.
        artifacts = h5read(filename, '/artifacts')';
        
        % Now, pull out the values for the correct channels and see if any
        % of them are True
        indices = get_indices(artifact_reject, extracted_channels);
        artifacts = artifacts(:, indices);
        artifact_mask = any(artifacts, 2)';
    else
        % We reject nothing
        artifact_mask = zeros(1, length(waveforms));
    end
    
    if length(trial_range) == 2, 
        lb = range(1);
        ub = range(2);
        epochs = double(h5read(filename, '/physiology_epoch'));
        fs = h5readatt(filename, '/physiology_epoch', 'fs');
        epochs(1,:) = epochs(1,:)-round(lb*fs);
        epochs(2,:) = epochs(2,:)+round(ub*fs);

        % Now, build a mask of all the event times that fall within the
        % requested range
        trial_mask = zeros(1, length(timestamps));
        for i = 1:length(epochs),
            submask = (timestamps >= epochs(1,i)) & (timestamps < epochs(2,i));
            trial_mask = trial_mask | submask;
        end
    else
        trial_mask = ones(1, length(timestamps));

    end

    % Now, cleanup our data according to the masks we have created
    mask = detect_mask & ~artifact_mask & trial_mask;
    waveforms = waveforms(mask, :, :);
    timestamps = timestamps(mask);
    channels = channels(mask);
    channel_indices = channel_indices(mask);

    % More ugly Matlab 1-based indexing issues
    %spikes.info.detect.discarded_start = start-1;
    % Even more ugly Matlab 1-based indexing issues
    %spikes.info.detect.discarded_stop = length(timestamps)-stop-1;
    % Phew, no ugly Matlab 1-based indexing issue here
    spikes.info.detect.settings = p.Results;
    spikes.info.detect.source_mask = mask;
    spikes.info.detect.detect_mask = detect_mask;
    spikes.info.trial.trial_mask = trial_mask;
    spikes.info.artifact.artifact_mask = artifact_mask;
    
    % Information saved in spikes.info.detect.settings reflects the actual
    % arguments passed to the function, not the values that were actually
    % used.
    spikes.info.detect.detect_channels = detect_channels;
    spikes.info.detect.waveform_channels = waveform_channels;
    spikes.info.detect.window_samples = size(waveforms, 2);
    spikes.info.detect.source_file = filename;
    
    if max_features > length(timestamps),
        max_features = length(timestamps);
    end
    spikes.waveforms = waveforms(1:max_features, :, :);
    spikes.timestamps = timestamps(1:max_features);
    spikes.channels = channels(1:max_features);
    spikes.channel_indices = channel_indices(1:max_features);
    
end

function [indices] = get_indices(channels, available_channels)
    indices = zeros(1, length(channels));
    for i = 1:length(channels),
        index = find(available_channels == channels(i));
        if ~isscalar(index),
            err = MException('Neurobehavior:InvalidChannel', ...
                             'Channel not available for extraction');
            throw(err);
        end
        indices(i) = index;
    end
end

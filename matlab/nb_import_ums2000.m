function [spikes] = nb_import_ums2000(filename, sort, varargin)
%   Neurobehavior by Buran BN and Sanes DH
%
%   NB_IMPORT_UMS2000 Load spike waveforms from HDF5 file into Matlab
%
%   required parameters
%   -------------------
%   filename : string
%       name of file to load data from (must be generated by the
%       review_physiology.py script in the neurobehavior module).
%   sort : boolean
%       Run spike sorting algorithms before returning
%
%   optional parameters
%   -------------------
%   All parameters supported by NB_IMPORT_SPIKES ar
%
%   Important information
%   ---------------------
%   * See NB_IMPORT_SPIKES for a list of the optional arguments that you can
%     pass along.
%   * You must use the modified version of some files from UMS2000. They are
%     present in this folder as remove_outliers.m and reintegrate_outliers.m.
%     By virtue of Matlab's lack of namespaces, we can simply ensure that the
%     modified version gets called by putting this folder at the top of Matlab's
%     path.
%
%   Returns struct containing spike waveform data that can be used directly by
%   UltraMegaSort2000.
% 
%   As a convenience feature, the filename of the source data (with the
%   extension stripped) is provided as spikes.base_filename so you can quickly
%   append your desired extension when saving the data.  It's probably good
%   practice to keep file naming consistent.

    % Load the spike waveform data
    spikes = nb_import_spikes(filename, varargin{:});
    
    fs = double(h5readatt(filename, '/event_data/waveforms', 'fs'));
    window_size = double(h5readatt(filename, '/event_data', 'window_size'));
    cross_time = double(h5readatt(filename, '/event_data', 'cross_time'));
    shadow = 0;
    
    params = ss_default_params(fs, 'window_size', window_size, ...
                               'cross_time', cross_time, ...
                               'shadow', shadow);
    spikes.params = params.params;

    % This is a new feature added to UMS2000 by BNB that allows the user to
    % provide an arbitrary number of fields (where each field's length is equal
    % to the number of events being sorted).  This will allow us to carry along
    % some important metadata about each event (e.g. the channel and how to find
    % it in the original extracted file) that UMS2000 doesn't handle by default.
    % For this, you *MUST* use Brad's version of UMS2000.
    extra_fields = {'channels', 'source_indices', 'channel_indices'};
    spikes.params.extra_fields = extra_fields;
    
    % Now, let's reformat some of the fields so the same data structure is
    % compatible with UltraMegaSort2000.  Note that we upcast a lot of the
    % datatypes to double simply because Matlab (and some functions in UMS2000)
    % do not seem to deal well with non-double datatypes.
    align_sample = h5readatt(filename, '/event_data', 'samples_before')+1.0;
    spikes.info.detect.align_sample = double(align_sample);
    spikes.info.detect.dur = [spikes.unwrapped_times(end)];
    stds = double(h5readatt(filename, '/event_data', 'noise_std'));
    thresh = double(h5readatt(filename, '/event_data', 'threshold'));
    
    extract_indices = spikes.info.detect.extract_indices;
    window_samples = spikes.info.detect.window_samples;
    
    spikes.info.detect.stds = stds(extract_indices);
    
    % UMS2000 requires that the maximum amplitude of the spike be in the
    % negative direction (for the alignment procedure).  If the spike was
    % detected using a positive threhsold, then we need to flip around the
    % waveform so that it is negative.
    thresh = thresh(extract_indices);
    spikes.info.detect.thresh = thresh;
    for i=length(thresh),
        if sign(thresh(i)) == 1,
            spikes.waveforms(:,:,i) = spikes.waveforms(:,:,i) * -1;
        end
    end
    
    % We need to pull out only the covariance data we need.wave
    cov_samples = length(extract_indices) * window_samples;
    % Explicitly requesting a 2D array is better than the implicit creation
    % of one ...
    cov_extracted = zeros(cov_samples, cov_samples);
    cov_full = double(h5read(filename, '/event_data/covariance_matrix'));
    
    % The code below is a beautiful example of why 0-based indexing is so
    % much better ... Anyway, we need to pull out the covariance data relating
    % to the channels we've extracted from the full covariance matrix.
    % http://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html
    for i = 1:length(extract_indices),
        for j = 1:length(extract_indices),
            % Indices required for obtaining slice of the full covariance matrix
            % to copy over ...
            x = extract_indices(i);
            y = extract_indices(j);
            full_xlb = (x-1)*window_samples+1;
            full_xub = x*window_samples;
            full_ylb = (y-1)*window_samples+1;
            full_yub = y*window_samples;

            % Indices of our covariance matrix that will be passed to UMS2000.
            e_xlb = (i-1)*window_samples+1;
            e_xub = i*window_samples;
            e_ylb = (j-1)*window_samples+1;
            e_yub = j*window_samples;

            xycov = cov_full(full_xlb:full_xub, full_ylb:full_yub);
            cov_extracted(e_xlb:e_xub, e_ylb:e_yub) = xycov;
        end
    end
    spikes.info.detect.cov = cov_extracted;
    
    % If we pulled out waveforms from more than one channel, then UMS2000 needs
    % to know what channel the detection event occured on so it can use that
    % channel for aligning the waveform.
    event_channels = zeros(length(spikes.waveforms), 1);
    waveform_channels = spikes.info.detect.waveform_channels;
    for i = 1:length(waveform_channels),
        event_channels(spikes.channels==waveform_channels(i)) = i;
    end
    spikes.info.detect.event_channel = event_channels;
    
    if sort,
        spikes = ss_align(spikes);
        spikes = ss_kmeans(spikes);
        spikes = ss_energy(spikes);
        spikes = ss_aggregate(spikes);
    end

    % Whoa, when I looked up how to use regular expressions in Matlab, someone
    % said text processing was one of Matlab's "hidden strengths".  Is that a
    % euphemisim for "bolted-on, poorly-implemented functionality"?  Personal
    % opinion aside, this appears to inherit from the Perl-style syntax.
    spikes.base_filename = regexprep(filename, '(.*)\.(h5|hd5|hdf5)', '$1');
end
